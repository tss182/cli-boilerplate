package approval

import (
	"enterprise/crf/domain/approval/entity"
	"enterprise/crf/shared"
	"enterprise/crf/shared/constant"
	"enterprise/crf/shared/message"
	"enterprise/crf/shared/response"
	"enterprise/crf/shared/validate"
	"fmt"
	"github.com/gofiber/fiber/v2"
)

type ApprovalHandlerInterface interface {
	entity.ApprovalHandlerInterface
}

type approvalHandler struct {
	feat entity.ApprovalFeatureInterface
}

func New(feat entity.ApprovalFeatureInterface) ApprovalHandlerInterface {
	return &approvalHandler{
		feat: feat,
	}
}

// GetByID godoc
// @Summary Approval Config List
// @Description Get Approval Config
// @Tags Master Approval Config
// @Accept json
// @Produce json
// @Param   product_group	path    string     true  "Product Group"
// @Success 200 {object} entity.ApprovalModel
// @Failure 400,404,500 {object} response.Response
// @Router /master/approval/{product_group} [get]
func (h *approvalHandler) GetByID(c *fiber.Ctx) error {
	dto := entity.ApprovalCodeModel{
		Username: c.Params("product_group"),
	}

	errs := validate.ValidateStruct(dto)
	if len(errs) > 0 {
		return response.BadRequest(c, message.DATA_VALIDATION, errs)
	}

	ctx, cancel := shared.CreateContextWithTimeoutAndValue(c)
	defer cancel()

	res, err := h.feat.GetByID(ctx, &dto.Username)
	shared.Exception(err, entity.Name)

	if len(res) == 0 {
		return response.OK(c, fmt.Sprintf(message.MSG_DATA, entity.Name), []interface{}{})
	}

	return response.OK(c, fmt.Sprintf(message.MSG_DATA, entity.Name), res)
}

// Update godoc
// @Summary Update Approval
// @Description Update existing user auth data
// @Tags Master Approval Config
// @Accept json
// @Produce json
// @Param   product_group	path    string     true  "Product Group"
// @Param payload body entity.ApprovalRequest true  "Payload"
// @Success 200 {object} response.Response
// @Failure 400,404,500 {object} response.Response
// @Router /master/approval/{product_group} [put]
func (h *approvalHandler) Update(c *fiber.Ctx) error {
	var dto []entity.ApprovalRequest
	err := c.BodyParser(&dto)
	shared.Exception(err, fmt.Sprintf(message.MSG_PAYLOAD, entity.Name))

	for _, v := range dto {
		errs := validate.ValidateStruct(v)
		if len(errs) > 0 {
			return response.BadRequest(c, message.DATA_VALIDATION, errs)
		}
	}

	ctx, cancel := shared.CreateContextWithTimeoutAndValue(c)
	defer cancel()

	productGroup := c.Params("product_group")
	err = h.feat.Update(ctx, productGroup, c.Locals(constant.REQ_USERNAME).(string), dto)
	shared.Exception(err, entity.Name)

	return response.OK(c, fmt.Sprintf(message.MSG_UPDATED, entity.Name), nil)
}
